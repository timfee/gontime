//
//  ContentView.swift
//  gontime
//
//  Created by Tim Feeley on 2/20/25.
//

import SwiftUI

struct ContentView: View {
    @EnvironmentObject var authViewModel: AuthenticationViewModel
    @EnvironmentObject var calendarSync: GoogleCalendarViewModel
    
    var body: some View {
        VStack {
            if case .signedIn = authViewModel.state {
                Text("Today's Events")
                    .font(.headline)
                List(calendarSync.events) { event in
                    VStack(alignment: .leading) {
                        Text(event.summary ?? "Unnamed event")
                            .font(.headline)
                        if let startTime = event.startTime, let endTime = event.endTime {
                            Text("\(startTime) - \(endTime)")
                                .font(.subheadline)
                        }
                        if let link = event.htmlLink {
                            Link("View Event", destination: URL(string: link)!)
                                .font(.footnote)
                        }
                    }
                }
                Button("Sign Out", action: authViewModel.signOut)
            } else {
                Button("Sign In with Google", action: authViewModel.signIn)
            }
        }
        .frame(width: 250)
        .padding()
    }
}

#Preview {
    ContentView()
}
//
//  GoogleEvent.swift
//  gontime
//
//  Created by Tim Feeley on 2/20/25.
//

import Foundation

struct GoogleEventsResponse: Codable {
    let items: [GoogleEvent]
}

struct GoogleEvent: Codable, Identifiable {
    let id: String
    let summary: String?
    let start: EventDateTime?
    let end: EventDateTime?
    let attendees: [Attendee]?
    let htmlLink: String?
    
    var startTime: Date? { start?.dateTime ?? start?.date }
    var endTime: Date? { end?.dateTime ?? end?.date }
}

struct EventDateTime: Codable {
    let dateTime: Date?
    let date: Date?
    
    init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)
        let formatter = ISO8601DateFormatter()
        formatter.formatOptions = [.withInternetDateTime]
        
        if let dateTimeString = try? container.decode(String.self, forKey: .dateTime) {
            dateTime = formatter.date(from: dateTimeString)
        } else {
            dateTime = nil
        }
        
        if let dateString = try? container.decode(String.self, forKey: .date) {
            let dateFormatter = DateFormatter()
            dateFormatter.dateFormat = "yyyy-MM-dd"
            dateFormatter.timeZone = TimeZone(secondsFromGMT: 0)
            date = dateFormatter.date(from: dateString)
        } else {
            date = nil
        }
    }
}

struct Attendee: Codable {
    let email: String
    let displayName: String?
}
//
//  ErrorManager.swift
//  gontime
//
//  Created by Tim Feeley on 2/20/25.
//

import SwiftUI

@MainActor
final class ErrorManager: ObservableObject {
    static let shared = ErrorManager()
    @Published var errorMessage: String? = nil {
        didSet {
            if errorMessage != nil {
                print("[DEBUG] ErrorManager: Showing error window...")
                openWindow(id: "errorWindow") // ✅ Correct SwiftUI method for menu bar apps
            } else {
                print("[DEBUG] ErrorManager: Dismissing error window.")
            }
        }
    }
    
    private init() {}
    
    func showError(_ message: String) {
        DispatchQueue.main.async { // ✅ Ensure error updates on the main thread
            print("[DEBUG] ErrorManager: Received error - \(message)")
            self.errorMessage = message
        }
    }
    
    func dismissError() {
        DispatchQueue.main.async {
            print("[DEBUG] ErrorManager: Clearing error message.")
            self.errorMessage = nil
        }
    }
}
//
//  GoogleCalendarService.swift
//  gontime
//
//  Created by Tim Feeley on 2/20/25.
//

import Foundation

final class GoogleCalendarService {
    func fetchEvents(accessToken: String) async -> [GoogleEvent] {
        let isoFormatter = ISO8601DateFormatter()
        isoFormatter.formatOptions = [.withInternetDateTime]
        
        let now = Date()
        let calendar = Calendar.current
        let startOfDay = calendar.startOfDay(for: now)
        let endOfDay = calendar.date(bySettingHour: 23, minute: 59, second: 59, of: startOfDay)!
        
        let timeMin = isoFormatter.string(from: startOfDay)
        let timeMax = isoFormatter.string(from: endOfDay)
        
        let urlString = "https://www.googleapis.com/calendar/v3/calendars/primary/events?timeMin=\(timeMin)&timeMax=\(timeMax)&singleEvents=true&orderBy=startTime"
        
        guard let url = URL(string: urlString) else { return [] }
        
        var request = URLRequest(url: url)
        request.httpMethod = "GET"
        request.addValue("Bearer \(accessToken)", forHTTPHeaderField: "Authorization")
        
        do {
            let (data, _) = try await URLSession.shared.data(for: request)
            let decodedResponse = try JSONDecoder().decode(GoogleEventsResponse.self, from: data)
            return decodedResponse.items
        } catch {
            print("Error fetching events: \(error.localizedDescription)")
            return []
        }
    }
}
//
//  GoogleSignInAuthenticator.swift
//  gontime
//
//  Created by Tim Feeley on 2/20/25.
//

import Foundation
import GoogleSignIn

final class GoogleSignInAuthenticator {
    func signIn(completion: @escaping (Result<GIDGoogleUser, Error>) -> Void) {
        guard let presentingWindow = NSApplication.shared.windows.first else {
            completion(.failure(NSError(domain: "SignIn", code: -1, userInfo: [NSLocalizedDescriptionKey: "No presenting window found!"])))
            return
        }
        
        let additionalScopes = ["https://www.googleapis.com/auth/calendar.readonly"]
        
        GIDSignIn.sharedInstance.signIn(withPresenting: presentingWindow, hint: nil, additionalScopes: additionalScopes) { result, error in
            
            // ✅ Handle explicit Google Sign-In cancellations
            if let error = error as NSError?, error.code == GIDSignInError.canceled.rawValue {
                completion(.failure(NSError(domain: "SignIn", code: -2, userInfo: [NSLocalizedDescriptionKey: "Sign-in was cancelled by the user."])))
                return
            }
            
            // ✅ Handle silent cancellation (result and error are nil)
            if result == nil {
                completion(.failure(NSError(domain: "SignIn", code: -3, userInfo: [NSLocalizedDescriptionKey: "Sign-in was cancelled or failed."])))
                return
            }
            
            guard let result = result else {
                completion(.failure(NSError(domain: "SignIn", code: -4, userInfo: [NSLocalizedDescriptionKey: "Sign-in failed."])))
                return
            }
            
            if let grantedScopes = result.user.grantedScopes, grantedScopes.contains("https://www.googleapis.com/auth/calendar.readonly") {
                completion(.success(result.user))
            } else {
                completion(.failure(NSError(domain: "SignIn", code: -5, userInfo: [NSLocalizedDescriptionKey: "Google Calendar permission was not granted."])))
            }
        }
    }
    
    func signOut() {
        GIDSignIn.sharedInstance.signOut()
    }
    
    func disconnect(completion: @escaping (Error?) -> Void) {
        GIDSignIn.sharedInstance.disconnect { error in
            completion(error)
        }
    }
}
//
//  AuthenticationViewModel.swift
//  gontime
//
//  Created by Tim Feeley on 2/20/25.
//

import SwiftUI
import GoogleSignIn

@MainActor
final class AuthenticationViewModel: ObservableObject {
    @Published var state: State = .signedOut {
        didSet {
            if case .error(let error) = state {
                print("[DEBUG] AuthenticationViewModel: Setting error state: \(error.localizedDescription)")
                ErrorManager.shared.showError(error.localizedDescription)
            } else {
                print("[DEBUG] AuthenticationViewModel: Clearing error state")
                ErrorManager.shared.dismissError()
            }
        }
    }
    
    private let authenticator = GoogleSignInAuthenticator()
    
    init() {
        if let user = GIDSignIn.sharedInstance.currentUser {
            print("[DEBUG] Restoring previous session for user: \(user.profile?.email ?? "Unknown")")
            state = .signedIn(user)
        } else {
            print("[DEBUG] No previous session found")
        }
    }
    
    func signIn() {
        print("[DEBUG] Starting Google Sign-In process...")
        
        authenticator.signIn { [weak self] result in
            guard let self = self else { return }
            
            switch result {
                case .success(let user):
                    print("[DEBUG] Sign-In Success: \(user.profile?.email ?? "Unknown")")
                    self.state = .signedIn(user)
                    
                case .failure(let error):
                    print("[DEBUG] Sign-In Failed: \(error.localizedDescription)")
                    
                    // ✅ Ensure error state is properly set
                    self.state = .error(error)
            }
        }
    }
    
    func signOut() {
        print("[DEBUG] Signing Out...")
        authenticator.signOut()
        state = .signedOut
    }
    
    func disconnect() {
        print("[DEBUG] Disconnecting Account...")
        authenticator.disconnect { [weak self] error in
            if let error = error {
                print("[DEBUG] Disconnect Failed: \(error.localizedDescription)")
                self?.state = .error(error)
            } else {
                print("[DEBUG] Disconnect Success")
                self?.signOut()
            }
        }
    }
    
    var validAccessToken: String? {
        guard case let .signedIn(user) = state else { return nil }
        return user.accessToken.tokenString
    }
    
    enum State {
        case signedIn(GIDGoogleUser)
        case signedOut
        case error(Error)
    }
}
//
//  GoogleCalendarViewModel.swift
//  gontime
//
//  Created by Tim Feeley on 2/20/25.
//

import SwiftUI
import Combine

@MainActor
final class GoogleCalendarViewModel: ObservableObject {
    @Published var events: [GoogleEvent] = []
    private var timerPublisher: AnyCancellable?
    private var cancellables = Set<AnyCancellable>()
    private let calendarService = GoogleCalendarService()
    private let authViewModel: AuthenticationViewModel
    
    init(authViewModel: AuthenticationViewModel) {
        self.authViewModel = authViewModel
        
        authViewModel.$state
            .sink { [weak self] state in
                guard let self else { return }
                self.handleAuthStateChange(state)
            }
            .store(in: &cancellables)
    }
    
    private func handleAuthStateChange(_ state: AuthenticationViewModel.State) {
        guard case .signedIn = state else {
            stopTimer()
            events = []
            return
        }
        Task { await fetchEvents() }
        startTimer()
    }
    
    private func fetchEvents() async {
        guard let accessToken = authViewModel.validAccessToken else { return }
        events = await calendarService.fetchEvents(accessToken: accessToken)
    }
    
    private func startTimer() {
        stopTimer()
        timerPublisher = Timer.publish(every: 60, on: .main, in: .common)
            .autoconnect()
            .sink { [weak self] _ in Task { await self?.fetchEvents() } }
    }
    
    private func stopTimer() {
        timerPublisher = nil
    }
}
//
//  ErrorWindow.swift
//  gontime
//
//  Created by Tim Feeley on 2/20/25.
//


import SwiftUI

struct ErrorWindow: View {
    @ObservedObject var errorManager = ErrorManager.shared
    
    var body: some View {
        VStack(spacing: 15) {
            Text("Error")
                .font(.title2)
                .bold()
                .foregroundColor(.red)
            Text(errorManager.errorMessage ?? "Unknown error")
                .font(.body)
                .multilineTextAlignment(.center)
                .padding()
            Button("OK") {
                errorManager.dismissError()
            }
            .keyboardShortcut(.defaultAction)
        }
        .frame(width: 300)
        .padding()
    }
}
//
//  gontimeApp.swift
//  gontime
//
//  Created by Tim Feeley on 2/20/25.
//


import SwiftUI
import GoogleSignIn

@main
struct gontimeApp: App {
    @StateObject private var authViewModel = AuthenticationViewModel()
    private var calendarSync: GoogleCalendarViewModel
    
    init() {
        // ✅ First, create authViewModel
        let authViewModelInstance = AuthenticationViewModel()
        
        // ✅ Then, safely initialize calendarSync
        self.calendarSync = GoogleCalendarViewModel(authViewModel: authViewModelInstance)
        
        // ✅ Restore Google Sign-In session
        GIDSignIn.sharedInstance.restorePreviousSignIn()
        
        // ✅ Now, properly assign the StateObject
        _authViewModel = StateObject(wrappedValue: authViewModelInstance)
    }
    
    var body: some Scene {
        MenuBarExtra("Agent", systemImage: "calendar") {
            ContentView()
                .environmentObject(authViewModel)
                .environmentObject(calendarSync)
        }
        .menuBarExtraStyle(.window)
        
        Window("Error", id: "errorWindow") {
            ErrorWindow()
        }
        .defaultSize(width: 300, height: 150)
        .windowResizability(.contentSize)
        
        Settings {
            EmptyView()
        }
    }
}
